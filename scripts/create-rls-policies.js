const { Client } = require('pg');

// Configuration de connexion
const config = {
  host: '147.93.58.155',
  port: 5432,
  database: 'saas_configurator',
  user: 'vpshostinger',
  password: 'Fethi@2025!',
  ssl: false
};

async function createRLSPolicies() {
  const client = new Client(config);
  
  try {
    console.log('üîê Cr√©ation des politiques RLS (Row Level Security)');
    console.log('=' .repeat(70));
    
    await client.connect();
    console.log('‚úÖ Connexion r√©ussie !');
    
    // 1. Activer RLS sur toutes les tables
    console.log('\n1Ô∏è‚É£ Activation de RLS sur toutes les tables...');
    
    const tables = [
      'users', 'companies', 'subscriptions', 'invoices', 'posts', 'comments',
      'communities', 'community_memberships', 'support_tickets', 'ticket_messages',
      'audit_logs', 'security_events', 'api_keys', 'data_exports', 'attachments',
      'email_templates', 'email_campaigns', 'webhooks', 'webhook_deliveries',
      'backup_jobs', 'feature_flags', 'system_settings', 'user_events', 'mfa_devices',
      'subscription_plans'
    ];
    
    for (const table of tables) {
      try {
        await client.query(`ALTER TABLE ${table} ENABLE ROW LEVEL SECURITY;`);
        console.log(`   ‚úÖ RLS activ√© sur ${table}`);
      } catch (error) {
        if (error.message.includes('already enabled')) {
          console.log(`   ‚ö†Ô∏è RLS d√©j√† activ√© sur ${table}`);
        } else {
          console.log(`   ‚ùå Erreur sur ${table}: ${error.message}`);
        }
      }
    }
    
    // 2. Cr√©er les politiques pour la table users
    console.log('\n2Ô∏è‚É£ Cr√©ation des politiques pour la table users...');
    
    const userPolicies = [
      // Les utilisateurs peuvent voir leur propre profil
      `CREATE POLICY "users_select_own" ON users FOR SELECT USING (id = current_setting('app.current_user_id', true)::uuid);`,
      
      // Les utilisateurs peuvent modifier leur propre profil
      `CREATE POLICY "users_update_own" ON users FOR UPDATE USING (id = current_setting('app.current_user_id', true)::uuid);`,
      
      // Les admins peuvent voir tous les utilisateurs
      `CREATE POLICY "users_select_admin" ON users FOR SELECT USING (current_setting('app.current_user_role', true) IN ('admin', 'superadmin'));`,
      
      // Les superadmins peuvent modifier tous les utilisateurs
      `CREATE POLICY "users_update_admin" ON users FOR UPDATE USING (current_setting('app.current_user_role', true) = 'superadmin');`,
      
      // Les superadmins peuvent ins√©rer de nouveaux utilisateurs
      `CREATE POLICY "users_insert_admin" ON users FOR INSERT WITH CHECK (current_setting('app.current_user_role', true) = 'superadmin');`,
      
      // Les superadmins peuvent supprimer des utilisateurs
      `CREATE POLICY "users_delete_admin" ON users FOR DELETE USING (current_setting('app.current_user_role', true) = 'superadmin');`
    ];
    
    for (const policy of userPolicies) {
      try {
        await client.query(policy);
        console.log(`   ‚úÖ Politique users cr√©√©e`);
      } catch (error) {
        if (error.message.includes('already exists')) {
          console.log(`   ‚ö†Ô∏è Politique users d√©j√† existante`);
        } else {
          console.log(`   ‚ùå Erreur politique users: ${error.message}`);
        }
      }
    }
    
    // 3. Cr√©er les politiques pour la table companies
    console.log('\n3Ô∏è‚É£ Cr√©ation des politiques pour la table companies...');
    
    const companyPolicies = [
      // Les utilisateurs peuvent voir leur propre entreprise
      `CREATE POLICY "companies_select_own" ON companies FOR SELECT USING (id = current_setting('app.current_user_company_id', true)::uuid);`,
      
      // Les admins peuvent voir toutes les entreprises
      `CREATE POLICY "companies_select_admin" ON companies FOR SELECT USING (current_setting('app.current_user_role', true) IN ('admin', 'superadmin'));`,
      
      // Les superadmins peuvent modifier toutes les entreprises
      `CREATE POLICY "companies_update_admin" ON companies FOR UPDATE USING (current_setting('app.current_user_role', true) = 'superadmin');`,
      
      // Les superadmins peuvent ins√©rer de nouvelles entreprises
      `CREATE POLICY "companies_insert_admin" ON companies FOR INSERT WITH CHECK (current_setting('app.current_user_role', true) = 'superadmin');`
    ];
    
    for (const policy of companyPolicies) {
      try {
        await client.query(policy);
        console.log(`   ‚úÖ Politique companies cr√©√©e`);
      } catch (error) {
        if (error.message.includes('already exists')) {
          console.log(`   ‚ö†Ô∏è Politique companies d√©j√† existante`);
        } else {
          console.log(`   ‚ùå Erreur politique companies: ${error.message}`);
        }
      }
    }
    
    // 4. Cr√©er les politiques pour la table subscriptions
    console.log('\n4Ô∏è‚É£ Cr√©ation des politiques pour la table subscriptions...');
    
    const subscriptionPolicies = [
      // Les utilisateurs peuvent voir leur propre abonnement
      `CREATE POLICY "subscriptions_select_own" ON subscriptions FOR SELECT USING (user_id = current_setting('app.current_user_id', true)::uuid);`,
      
      // Les admins peuvent voir tous les abonnements
      `CREATE POLICY "subscriptions_select_admin" ON subscriptions FOR SELECT USING (current_setting('app.current_user_role', true) IN ('admin', 'superadmin'));`,
      
      // Les superadmins peuvent modifier tous les abonnements
      `CREATE POLICY "subscriptions_update_admin" ON subscriptions FOR UPDATE USING (current_setting('app.current_user_role', true) = 'superadmin');`,
      
      // Les superadmins peuvent ins√©rer de nouveaux abonnements
      `CREATE POLICY "subscriptions_insert_admin" ON subscriptions FOR INSERT WITH CHECK (current_setting('app.current_user_role', true) = 'superadmin');`
    ];
    
    for (const policy of subscriptionPolicies) {
      try {
        await client.query(policy);
        console.log(`   ‚úÖ Politique subscriptions cr√©√©e`);
      } catch (error) {
        if (error.message.includes('already exists')) {
          console.log(`   ‚ö†Ô∏è Politique subscriptions d√©j√† existante`);
        } else {
          console.log(`   ‚ùå Erreur politique subscriptions: ${error.message}`);
        }
      }
    }
    
    // 5. Cr√©er les politiques pour la table posts
    console.log('\n5Ô∏è‚É£ Cr√©ation des politiques pour la table posts...');
    
    const postPolicies = [
      // Les utilisateurs peuvent voir les posts publics et de leurs communaut√©s
      `CREATE POLICY "posts_select_public" ON posts FOR SELECT USING (
        visibility = 'public' OR 
        (visibility = 'community' AND community_id IN (
          SELECT community_id FROM community_memberships 
          WHERE user_id = current_setting('app.current_user_id', true)::uuid
        )) OR
        author_id = current_setting('app.current_user_id', true)::uuid
      );`,
      
      // Les utilisateurs peuvent cr√©er des posts
      `CREATE POLICY "posts_insert_own" ON posts FOR INSERT WITH CHECK (author_id = current_setting('app.current_user_id', true)::uuid);`,
      
      // Les utilisateurs peuvent modifier leurs propres posts
      `CREATE POLICY "posts_update_own" ON posts FOR UPDATE USING (author_id = current_setting('app.current_user_id', true)::uuid);`,
      
      // Les utilisateurs peuvent supprimer leurs propres posts
      `CREATE POLICY "posts_delete_own" ON posts FOR DELETE USING (author_id = current_setting('app.current_user_id', true)::uuid);`,
      
      // Les admins peuvent voir tous les posts
      `CREATE POLICY "posts_select_admin" ON posts FOR SELECT USING (current_setting('app.current_user_role', true) IN ('admin', 'superadmin'));`
    ];
    
    for (const policy of postPolicies) {
      try {
        await client.query(policy);
        console.log(`   ‚úÖ Politique posts cr√©√©e`);
      } catch (error) {
        if (error.message.includes('already exists')) {
          console.log(`   ‚ö†Ô∏è Politique posts d√©j√† existante`);
        } else {
          console.log(`   ‚ùå Erreur politique posts: ${error.message}`);
        }
      }
    }
    
    // 6. Cr√©er les politiques pour la table comments
    console.log('\n6Ô∏è‚É£ Cr√©ation des politiques pour la table comments...');
    
    const commentPolicies = [
      // Les utilisateurs peuvent voir les commentaires des posts qu'ils peuvent voir
      `CREATE POLICY "comments_select_visible" ON comments FOR SELECT USING (
        post_id IN (
          SELECT id FROM posts WHERE 
          visibility = 'public' OR 
          (visibility = 'community' AND community_id IN (
            SELECT community_id FROM community_memberships 
            WHERE user_id = current_setting('app.current_user_id', true)::uuid
          )) OR
          author_id = current_setting('app.current_user_id', true)::uuid
        )
      );`,
      
      // Les utilisateurs peuvent cr√©er des commentaires
      `CREATE POLICY "comments_insert_own" ON comments FOR INSERT WITH CHECK (author_id = current_setting('app.current_user_id', true)::uuid);`,
      
      // Les utilisateurs peuvent modifier leurs propres commentaires
      `CREATE POLICY "comments_update_own" ON comments FOR UPDATE USING (author_id = current_setting('app.current_user_id', true)::uuid);`,
      
      // Les utilisateurs peuvent supprimer leurs propres commentaires
      `CREATE POLICY "comments_delete_own" ON comments FOR DELETE USING (author_id = current_setting('app.current_user_id', true)::uuid);`
    ];
    
    for (const policy of commentPolicies) {
      try {
        await client.query(policy);
        console.log(`   ‚úÖ Politique comments cr√©√©e`);
      } catch (error) {
        if (error.message.includes('already exists')) {
          console.log(`   ‚ö†Ô∏è Politique comments d√©j√† existante`);
        } else {
          console.log(`   ‚ùå Erreur politique comments: ${error.message}`);
        }
      }
    }
    
    // 7. Cr√©er les politiques pour la table support_tickets
    console.log('\n7Ô∏è‚É£ Cr√©ation des politiques pour la table support_tickets...');
    
    const ticketPolicies = [
      // Les utilisateurs peuvent voir leurs propres tickets
      `CREATE POLICY "tickets_select_own" ON support_tickets FOR SELECT USING (user_id = current_setting('app.current_user_id', true)::uuid);`,
      
      // Les utilisateurs peuvent cr√©er des tickets
      `CREATE POLICY "tickets_insert_own" ON support_tickets FOR INSERT WITH CHECK (user_id = current_setting('app.current_user_id', true)::uuid);`,
      
      // Les utilisateurs peuvent modifier leurs propres tickets
      `CREATE POLICY "tickets_update_own" ON support_tickets FOR UPDATE USING (user_id = current_setting('app.current_user_id', true)::uuid);`,
      
      // Les admins peuvent voir tous les tickets
      `CREATE POLICY "tickets_select_admin" ON support_tickets FOR SELECT USING (current_setting('app.current_user_role', true) IN ('admin', 'superadmin'));`,
      
      // Les admins peuvent modifier tous les tickets
      `CREATE POLICY "tickets_update_admin" ON support_tickets FOR UPDATE USING (current_setting('app.current_user_role', true) IN ('admin', 'superadmin'));`
    ];
    
    for (const policy of ticketPolicies) {
      try {
        await client.query(policy);
        console.log(`   ‚úÖ Politique support_tickets cr√©√©e`);
      } catch (error) {
        if (error.message.includes('already exists')) {
          console.log(`   ‚ö†Ô∏è Politique support_tickets d√©j√† existante`);
        } else {
          console.log(`   ‚ùå Erreur politique support_tickets: ${error.message}`);
        }
      }
    }
    
    // 8. Cr√©er les politiques pour les tables d'audit et de s√©curit√©
    console.log('\n8Ô∏è‚É£ Cr√©ation des politiques pour les tables d\'audit...');
    
    const auditPolicies = [
      // Seuls les admins peuvent voir les logs d'audit
      `CREATE POLICY "audit_logs_select_admin" ON audit_logs FOR SELECT USING (current_setting('app.current_user_role', true) IN ('admin', 'superadmin'));`,
      
      // Seuls les superadmins peuvent ins√©rer des logs d'audit
      `CREATE POLICY "audit_logs_insert_admin" ON audit_logs FOR INSERT WITH CHECK (current_setting('app.current_user_role', true) = 'superadmin');`,
      
      // Seuls les admins peuvent voir les √©v√©nements de s√©curit√©
      `CREATE POLICY "security_events_select_admin" ON security_events FOR SELECT USING (current_setting('app.current_user_role', true) IN ('admin', 'superadmin'));`,
      
      // Seuls les superadmins peuvent ins√©rer des √©v√©nements de s√©curit√©
      `CREATE POLICY "security_events_insert_admin" ON security_events FOR INSERT WITH CHECK (current_setting('app.current_user_role', true) = 'superadmin');`
    ];
    
    for (const policy of auditPolicies) {
      try {
        await client.query(policy);
        console.log(`   ‚úÖ Politique d'audit cr√©√©e`);
      } catch (error) {
        if (error.message.includes('already exists')) {
          console.log(`   ‚ö†Ô∏è Politique d'audit d√©j√† existante`);
        } else {
          console.log(`   ‚ùå Erreur politique d'audit: ${error.message}`);
        }
      }
    }
    
    // 9. Cr√©er les politiques pour les tables d'administration
    console.log('\n9Ô∏è‚É£ Cr√©ation des politiques pour les tables d\'administration...');
    
    const adminTables = [
      'admin_database_config', 'admin_chatbot_config', 'admin_system_config',
      'admin_security_config', 'admin_mailing_config', 'admin_appearance_config',
      'admin_legal_config', 'admin_community_config', 'admin_analytics_config',
      'admin_configurations'
    ];
    
    for (const table of adminTables) {
      try {
        // Seuls les superadmins peuvent acc√©der aux configurations d'administration
        await client.query(`CREATE POLICY "${table}_admin_only" ON ${table} FOR ALL USING (current_setting('app.current_user_role', true) = 'superadmin');`);
        console.log(`   ‚úÖ Politique ${table} cr√©√©e`);
      } catch (error) {
        if (error.message.includes('already exists')) {
          console.log(`   ‚ö†Ô∏è Politique ${table} d√©j√† existante`);
        } else {
          console.log(`   ‚ùå Erreur politique ${table}: ${error.message}`);
        }
      }
    }
    
    // 10. V√©rification finale
    console.log('\nüîç V√©rification finale des politiques RLS...');
    
    const policiesQuery = `
      SELECT schemaname, tablename, policyname, permissive, roles, cmd, qual
      FROM pg_policies 
      WHERE schemaname = 'public'
      ORDER BY tablename, policyname
    `;
    const policiesResult = await client.query(policiesQuery);
    console.log(`üîê Politiques RLS cr√©√©es: ${policiesResult.rows.length}`);
    
    // Grouper par table
    const policiesByTable = {};
    policiesResult.rows.forEach(row => {
      if (!policiesByTable[row.tablename]) {
        policiesByTable[row.tablename] = [];
      }
      policiesByTable[row.tablename].push(row.policyname);
    });
    
    console.log('\nüìã Politiques par table:');
    Object.keys(policiesByTable).sort().forEach(table => {
      console.log(`   ${table}: ${policiesByTable[table].length} politiques`);
      policiesByTable[table].forEach(policy => {
        console.log(`     - ${policy}`);
      });
    });
    
    console.log('\nüéâ POLITIQUES RLS CR√â√âES AVEC SUCC√àS !');
    console.log('üîê La s√©curit√© au niveau des lignes est maintenant active.');
    console.log('üõ°Ô∏è Chaque utilisateur ne peut acc√©der qu\'aux donn√©es autoris√©es.');
    console.log('üëë Les superadmins ont un acc√®s complet √† toutes les donn√©es.');
    console.log('üöÄ L\'application est maintenant s√©curis√©e au niveau de la base de donn√©es !');
    
  } catch (error) {
    console.error('‚ùå Erreur lors de la cr√©ation des politiques RLS:', error.message);
  } finally {
    await client.end();
    console.log('\nüîö Cr√©ation des politiques RLS termin√©e !');
  }
}

createRLSPolicies();
